<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Batch Filter Functions: posVel - vanilla EOMs of position and velocity</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Basilisk-Logo.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Batch Filter Functions
   &#160;<span id="projectnumber">0.1.5</span>
   </div>
   <div id="projectbrief">Functions shared amongst differing batch filters</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">posVel - vanilla EOMs of position and velocity</div>  </div>
</div><!--header-->
<div class="contents">

<p>The module for the EOMs and A matrix for position and velocity.  
<a href="#details">More...</a></p>
<p>The module for the EOMs and A matrix for position and velocity. </p>
<h1><a class="anchor" id="overview"></a>
Overview </h1>
<h2>Purpose </h2>
<p>This script contains two exportable functions. This module hosts the equations of motion (EOMs) to be called by a desired propagator, as well as the code necessary to formulate a relevant A matrix. This matrix is essential to propagating deviations under linear assumptions and is utilized in the EOMs for the propagation of the STM.</p>
<h2>Contents </h2>
<p>The following exportable functions are contained in this module:</p>
<ul>
<li><code>matrixA</code></li>
<li><code>EOM</code></li>
</ul>
<p>The <code>matrixA</code> function is used for the calculation of the A matrix, which is composed of various derivatives of the quantities of interest. This matrix is further explained in this documentation. The <code>EOM</code> function ultimately calls the <code>matrixA</code> function, and calculates the time derivatives of the quantities of interest for the filter propagator. <code>EOM</code> contains a number of accelerations such as that from gravity or SRP.</p>
<h1>The Code </h1>
<h2><code>matrixA</code> </h2>
<p>The A matrix is the first order derivative of the state derived from linear assumptions. Because of this, its formulation relies on knowing the time derivatives of the quantities of interest, and the derivatives of these with respect to the quantities of interest themselves. The mathematical formulation of this matrix is found in Eq. 4.2.6 of Tapley, Schutz and Born, and it is illustrated in Example 4.2.1. A table of required input is provided below:</p>
<table class="doxtable">
<tr>
<th>Name </th><th>Description </th><th>Size/Type  </th></tr>
<tr>
<td>spacecraftPosition </td><td>position of spacecraft. original input of full state </td><td>(d,) numpy array </td></tr>
<tr>
<td>nSecondaries </td><td>number of secondary gravitational bodies </td><td>int </td></tr>
<tr>
<td>muPrimary </td><td>gravitational parameter of primary gravitational body </td><td>float </td></tr>
<tr>
<td>muSecondaries </td><td>list of secondary body gravitional parameters </td><td>list </td></tr>
<tr>
<td>kSRP </td><td>solar radiation pressure constant </td><td>float </td></tr>
<tr>
<td>cR </td><td>spacecraft coefficient of reflectivity </td><td>float </td></tr>
<tr>
<td>sunPosition </td><td>position of the sun </td><td>(3,) numpy array </td></tr>
<tr>
<td>position_secondaries_primary </td><td>relative positions of secondary bodies with respect to primary </td><td>(3, nSecondaries) numpy array </td></tr>
</table>
<p>The output of this function is the A matrix:</p>
<table class="doxtable">
<tr>
<th>Name </th><th>Description </th><th>Size/Type  </th></tr>
<tr>
<td>A </td><td>matrix derived from first order linear assumptions </td><td>(d,d) numpy array </td></tr>
</table>
<p>This function runs off of the assumption that the filter quantities of interest are limited to position and velocity. Therefore, the derivations needed involve taking derivatives of acceleration with respect to position, as the EOMs are invariant with respect to velocity, and the velocity is invariant with respect to position. A figure is provided to illustrate the compositon of the A matrix in this case.</p>
<div class="image">
<object type="image/svg+xml" data="matrixA.svg">matrixA.svg</object>
</div>
<p>Here, we consider each component of the acceleration derivatives. It is noted that each derivative is solved for in a vector format, so the accelerations are able to be summed up with little fanfare at the end.</p>
<p>First, the acceleration due to the primary body gravity is taken with respect to position: </p><div class="fragment"><div class="line"><span class="comment"># the spacecraftPosition derivate associated with the primary gravitational force</span></div><div class="line">dFdR_p = -muPrimary * ( np.identity(3) / np.linalg.norm(spacecraftPosition) ** 3 -\</div><div class="line">3 * np.dot(spacecraftPosition, spacecraftPosition.T) / \</div><div class="line">np.linalg.norm(spacecraftPosition) ** 5 )</div></div><!-- fragment --><p>This is followed up by looping through the list of secondary bodies and calculating the position derivatives of the contributed gravitational accelerations: </p><div class="fragment"><div class="line"><span class="comment"># loop through the secondary bodies</span></div><div class="line"><span class="keywordflow">for</span> ii <span class="keywordflow">in</span> xrange(nSecondaries) :</div><div class="line">    positionSecondary = np.expand_dims( position_secondaries_primary[:, ii], axis = 1 )</div><div class="line">    dFdR_s += -muSecondaries[ii] * (</div><div class="line">    np.identity(3) / np.linalg.norm(spacecraftPosition - positionSecondary) ** 3 -\</div><div class="line">    3 * np.dot(spacecraftPosition - positionSecondary,(spacecraftPosition -\</div><div class="line">    positionSecondary).T)/np.linalg.norm(spacecraftPosition - positionSecondary) ** 5)</div></div><!-- fragment --><p>Lastly, we address the derivatives of the SRP acceleration and sum up all accleration derivatives: </p><div class="fragment"><div class="line"><span class="comment"># the spacecraftPosition derivative associated with the SRP force</span></div><div class="line">dFdR_SRP = cR * kSRP * (np.identity(3) / \</div><div class="line">   np.linalg.norm(spacecraftPosition - sunPosition) ** 3 -</div><div class="line">   3 * np.dot(spacecraftPosition - sunPosition, (spacecraftPosition - sunPosition).T) /\</div><div class="line">                        np.linalg.norm(spacecraftPosition - sunPosition) ** 5)</div><div class="line"><span class="comment"># total spacecraftPosition derivatives of forces</span></div><div class="line">dFdR = dFdR_p + dFdR_s + dFdR_SRP</div></div><!-- fragment --><p>The A matrix is then populated with these values, as well as 1s for velocity derivatives, and is returned to the function that called it.</p>
<h2><code>EOM</code> </h2>
<p><code>EOM</code> is a function that computes the equations of motion when given appropriate inputs including the state, timestep and various force parameters. The list of inputs is long, but all are necessary for the function to operate properly</p>
<table class="doxtable">
<tr>
<th>Name </th><th>Description </th><th>Size/Type  </th></tr>
<tr>
<td>state </td><td>input state of the quantities of interest and STM for the considered time step</td><td>(d(1+d),) numpy array </td></tr>
<tr>
<td>et </td><td>time step for propagator </td><td>float </td></tr>
<tr>
<td>primaryIndex</td><td>index of the primary body in the bodies list </td><td>int </td></tr>
<tr>
<td>secondaryIndices</td><td>indices of the seoncdary bodies in the bodies list </td><td>list of int </td></tr>
<tr>
<td>nSecondaries</td><td>number of secondary bodies </td><td>int </td></tr>
<tr>
<td>muPrimary</td><td>gravitational parameter of primary body </td><td>float </td></tr>
<tr>
<td>muSecondaries</td><td>gravitational parameters of secondary bodies </td><td>list of floats </td></tr>
<tr>
<td>kSRP</td><td>solar radiation pressure coefficient </td><td>float </td></tr>
<tr>
<td>cR</td><td>spacecraft coefficient of reflectivity </td><td>float </td></tr>
<tr>
<td>abcorr</td><td>aberration correction for SPICE (not considered as of 11/17) </td><td>float </td></tr>
<tr>
<td>refFrame</td><td>reference frame for SPICE </td><td>str </td></tr>
<tr>
<td>bodies</td><td>list of gravitational bodies for SPICE </td><td>list of str </td></tr>
<tr>
<td>stateDimension </td><td>dimension of the filter quantities of interest </td><td>int </td></tr>
</table>
<p>The same is repeated for outputs:</p>
<table class="doxtable">
<tr>
<th>Name </th><th>Description </th><th>Size/Type  </th></tr>
<tr>
<td>dState </td><td>quantity of interest and STM derivatives to be integrated </td><td>list of float </td></tr>
</table>
<p>As with many EOM functions, this code is largely devoted to calculating and arranging the desired accelerations in the scenario. This function does contain interesting behavior when considering the STM and the gravitational bodies. The STM is resized for input so that the <code>state</code> variable is not a matrix, but a vector. The position of gravitational bodies in the considered reference frame (<code>refFrame</code>) a found via the SPICE tool. We first see this when calculating the gravitational force contributed by the secondary bodies. Before this, however, we consider the gravitational acceleration of the primary body: </p><div class="fragment"><div class="line"><span class="comment"># gravitational force from primary body</span></div><div class="line">fPrimary = -muPrimary * state[0:3] / np.linalg.norm(state[0:3]) ** 3</div></div><!-- fragment --><p>Here, we note that there is an assumption that the input <code>state</code> is the position of the spacecraft with respect to the sun. This is true for all data that is generated via the <code>data_generation</code> function.</p>
<p>Following this, we have a loop over the number of secondary bodies. The accelerations due to these bodies are linearly summed. The position of the secondary body with respect to the primary body is found first: </p><div class="fragment"><div class="line"><span class="comment"># determine distance from secondary to primary body</span></div><div class="line">positionArray = np.zeros(3)</div><div class="line">stateSpice = pyswice.new_doubleArray(6)</div><div class="line">lt = pyswice.new_doubleArray(1)</div><div class="line">pyswice.spkezr_c(bodies[secondaryIndices[ii]], et, refFrame,</div><div class="line">                abcorr, bodies[primaryIndex], stateSpice, lt)</div><div class="line"><span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(3):</div><div class="line">    positionArray[i] = pyswice.doubleArray_getitem(stateSpice, i)</div><div class="line">position_secondaries_primary[:, ii] = positionArray</div></div><!-- fragment --><p>We note that the <code>pyswice.spkezr_c()</code> line contains the indexing for the secondary body <code>bodies[secondaryIndices[ii]]</code>, as well as centering the position vector on the primary body by using the corresponding index <code>primaryIndex</code>. Using this relative position, we are then able to calculate the acceleration contribution. </p><div class="fragment"><div class="line"><span class="comment"># calculate the &quot;third body&quot; force</span></div><div class="line">f3rdBodies += -muSecondaries[ii] * \</div><div class="line">   ( ( state[0:3] - position_secondaries_primary[:, ii] ) / \</div><div class="line">     np.linalg.norm(state[0:3] - position_secondaries_primary[:, ii] ) ** 3 + \</div><div class="line">     position_secondaries_primary[:, ii] / \</div><div class="line">     np.linalg.norm( position_secondaries_primary[:, ii] )**3 )</div></div><!-- fragment --><p>The final acceleration in this function is that of solar radiation pressure (SRP). This is a function of the distance from the sun to the spacecraft, i.e., </p><div class="fragment"><div class="line"><span class="comment"># SRP force</span></div><div class="line">fSRP = cR * kSRP * state[0:3] / np.linalg.norm(state[0:3]) ** 3</div></div><!-- fragment --><p>The acceleration vectors are then able to be summed. Various force sources can be added to this basic template. This is seen in the pos_vel_acc <code>posVelAcc.py</code> function.</p>
<p>Finally, the derivative of the STM is calculate by computing the A matrix and multiplying it with the most recent STM. This is found in Eq. 4.2.10 and 4.2.24 of Tapley, Schutz and Born, and is accomplished via the following lines of code </p><div class="fragment"><div class="line"><span class="comment"># A matrix calculation</span></div><div class="line">A = matrixA(args)</div><div class="line"></div><div class="line"><span class="comment"># compute the derivative of the STM</span></div><div class="line">dPhi = np.dot(A, phi)</div></div><!-- fragment --><p>The STM is then reshaped to a vector and appended to the derivative of the state. </p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 18 2017 11:12:40 for Batch Filter Functions by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
