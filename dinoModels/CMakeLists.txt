cmake_minimum_required(VERSION 2.8)
include(ExternalProject)

set(BasiliskTopDir "${CMAKE_CURRENT_SOURCE_DIR}/../../Basilisk")
project("DINO_CREx")

#! make_python_package : create python package
#
# This function creates a python package directory and adds an __init__.py 
# file or copies an existing custom __init__.py file. A list of package 
# supporting files may be passed as the thried parameter. The function takes
# three arguments.
#
# \arg:FileBase the desired python package name
# \arg:FileDir the directory path relative to the cmake script calling the function
# \arg:moduleFilePath path to the Basilisk module's resulting python package directory 
#
function(make_python_package FileBase FileDir moduleFilePath)
	
	make_python_package_dir(${FileBase} ${FileDir})
	# Create symlinks in the python package directory to any 
	# Basilisk module supporting files. 
	file(GLOB supportingFiles 
		"${CMAKE_CURRENT_SOURCE_DIR}/${FileDir}/*.xml" 
		"${CMAKE_CURRENT_SOURCE_DIR}/${FileDir}/*.py")
	list(REMOVE_ITEM supportingFiles ${CMAKE_CURRENT_SOURCE_DIR}/${FileDir}/__init__.py)
	
	create_symlinks(${moduleFilePath} ${supportingFiles})
endfunction(make_python_package)


#! create_symlinks : create python package directory
#
# This function creates symlinks to supporting files for python packages. 
# The function takes one required argument and N optional arguments.
#
# \arg:destinationPath the desired location in which to create the symlinks
# \argn: a list of supporting file paths 
#
function(create_symlinks destinationPath)
    # Do nothing if building in-source
    if (${CMAKE_CURRENT_BINARY_DIR} STREQUAL ${CMAKE_CURRENT_SOURCE_DIR})
        return()
    endif()
	#message(destinationPath: ${destinationPath})
	#message(ARGN: ${ARGN})
    foreach (filePath ${ARGN})
        get_filename_component(fileName ${filePath} NAME)
# message(${folder})
#         # Create REAL folder
#         file(MAKE_DIRECTORY "${destinationPath}/${folder}")
# message("directory created: ${destinationPath}/${folder}")
        # Delete symlink if it exists
        # file(REMOVE "${CMAKE_CURRENT_BINARY_DIR}/${path_file}")

        # Get OS dependent path to use in `execute_process`
        file(TO_NATIVE_PATH "${destinationPath}/${fileName}" link)
        file(TO_NATIVE_PATH "${filePath}" target)
        file(REMOVE ${destinationPath}/${fileName})

        if (UNIX)
            set(command ln -s ${target} ${link})
        else()
            set(command cmd.exe /c mklink ${link} ${target})
        endif()

        execute_process(COMMAND ${command} 
                        RESULT_VARIABLE result
                        ERROR_VARIABLE output)

        if (NOT ${result} EQUAL 0)
            file( COPY ${target} DESTINATION ${destinationPath})
            message("Could not create symbolic link for: ${target} --> ${output}.  Copied instead")
        endif()

    endforeach(filePath)
endfunction(create_symlinks)


#! make_python_package_dir : create python package directory
#
# This function creates a python package directory and adds an __init__.py 
# file or copies an existing custom __init__.py file. The function takes
# two arguments.
#
# \arg:FileBase the desired python package name
# \arg:FileDir the directory path relative to the cmake script calling the function
#
function(make_python_package_dir FileBase FileDir)
	# message(FileBase: ${FileBase})
	# message(FileDir: ${FileDir})
	set(destination ${CMAKE_SOURCE_DIR}/modules/${FileBase})
    file(MAKE_DIRECTORY "${CMAKE_SOURCE_DIR}/modules/${FileBase}")
	if(NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/${FileDir}/__init__.py")
		file(WRITE "__init__.py" "# This __init__.py file for the ${FileBase} package is automatically generated by the build system 
from ${FileBase} import *")
		file(COPY "__init__.py" DESTINATION ${destination})
	else()
		configure_file(${CMAKE_CURRENT_SOURCE_DIR}/${FileDir}/__init__.py ${destination}/__init__.py COPYONLY)
	endif()
	if (EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/__init__.py")
		file(REMOVE "__init__.py")
	endif()
endfunction(make_python_package_dir)

# Start of main projection configuration
find_package(PythonLibs 2.7 REQUIRED)
find_package(PythonInterp 2.7 REQUIRED)

# set(CMAKE_SWIG_OUTDIR ${CMAKE_SOURCE_DIR}/modules)

# Add general compiler flags
set(CMAKE_MACOSX_RPATH 1)
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O2")

# Add platform specific compiler flags
set(Boost_USE_STATIC_LIBS ON)
set(Boost_USE_STATIC_RUNTIME ON)
if(MSVC)
    add_definitions(/D _CRT_SECURE_NO_WARNINGS)
    add_definitions(/D _WINSOCK_DEPRECATED_NO_WARNINGS)
    add_definitions(/D _WIN32_WINNT=0x0501) # Targets Windows xp
    add_definitions(/D BOOST_ALL_NO_LIB)
    add_definitions(/W3)
    add_definitions(/wd"4913")
    # Make sure we are using Multi-Threaded run time library
    foreach(flag 
        CMAKE_C_FLAGS
        CMAKE_C_FLAGS_DEBUG
        CMAKE_C_FLAGS_RELEASE
        CMAKE_CXX_FLAGS
        CMAKE_CXX_FLAGS_DEBUG
        CMAKE_CXX_FLAGS_RELEASE)
        string(REPLACE "/D_DEBUG" "" "${flag}" "${${flag}}")
        string(REPLACE "/MD" "/MT" "${flag}" "${${flag}}")
        string(REPLACE "/MDd" "/MT" "${flag}" "${${flag}}")
        string(REPLACE "/MTd" "/MT" "${flag}" "${${flag}}")
        set("${flag}" "${${flag}} /EHsc")
    endforeach()
elseif(APPLE)
	set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -g -gdwarf-3")
	set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g -gdwarf-3 -std=c++11 -stdlib=libc++")
	set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g -gdwarf-3")
    set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE}  -Wall")
	set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG}  -Wall")
else()
	set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -g -gdwarf-3")
	set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g -gdwarf-3 -std=c++11 -fPIC")
	set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g -gdwarf-3")
    set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE}  -Wall")
	set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG}  -Wall")
    set(Boost_USE_STATIC_LIBS OFF)
    set(Boost_USE_STATIC_RUNTIME OFF)

endif()

find_package(SWIG 3.0)

#ExternalProject_Add(BASILISK
#                    SOURCE_DIR ${BasiliskTopDir}
#                    INSTALL_COMMAND ""
#                    CMAKE_ARGS -DCMAKE_CXX_FLAGS=${CMAKE_CXX_FLAGS} 
#                        -DCMAKE_C_FLAGS=${CMAKE_C_FLAGS}
#                        -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}
#                        -DSWIG_DIR=${SWIG_DIR}
#                        -DSWIG_EXECUTABLE=${SWIG_EXECUTABLE} ${USE_PROJECT_CMAKE_MODULE_PATH}
#                    )

foreach( OUTPUTCONFIG ${CMAKE_CONFIGURATION_TYPES} )
    string( TOUPPER ${OUTPUTCONFIG} OUTPUTCONFIG )
    set( CMAKE_RUNTIME_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${CMAKE_SOURCE_DIR}/modules )
    set( CMAKE_LIBRARY_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${CMAKE_SOURCE_DIR}/modules )
    set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${CMAKE_SOURCE_DIR}/modules )
endforeach( OUTPUTCONFIG CMAKE_CONFIGURATION_TYPES )

# Add include directories
include_directories(SimCode)
include_directories("${BasiliskTopDir}/SimCode")
include_directories("${BasiliskTopDir}/External")
include_directories("${BasiliskTopDir}/FswAlgorithms")

# Manually create list of libraries depending on system
if(WIN32)
	set(library_dependencies 
      	${BasiliskTopDir}/modules/SimMessaging.lib ${BasiliskTopDir}/modules/SimUtilities.lib ${BasiliskTopDir}/modules/AlgorithmMessaging.lib
	)
elseif(APPLE)
	set(library_dependencies 
      	${BasiliskTopDir}/modules/libSimMessaging.dylib ${BasiliskTopDir}/modules/libSimUtilities.a ${BasiliskTopDir}/modules/libAlgorithmMessaging.a
	)
	# use, i.e. don't skip the full RPATH for the build tree
	SET(CMAKE_SKIP_BUILD_RPATH  FALSE)

	# when building, don't use the install RPATH already
	# (but later on when installing)
	SET(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE) 

	# the RPATH to be used when installing
	SET(CMAKE_INSTALL_RPATH "${CMAKE_SOURCE_DIR}/modules:${BasiliskTopDir}/modules")

	# don't add the automatically determined parts of the RPATH
	# which point to directories outside the build tree to the install RPATH
	SET(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)	
else()
	set(library_dependencies 
      	${BasiliskTopDir}/modules/libSimMessaging.so ${BasiliskTopDir}/modules/libSimUtilities.a ${BasiliskTopDir}/modules/libAlgorithmMessaging.a
	)
	set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)
	set(CMAKE_INSTALL_RPATH "\$ORIGIN/../")
endif()

set_property(GLOBAL PROPERTY USE_FOLDERS ON)

add_subdirectory("SimCode")
add_subdirectory("ADCSAlgorithms")

